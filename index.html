<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Ninja Nephews</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #121925;
      --panel2: #0f1622;
      --ink: #e7eefc;
      --muted: #a8b3c7;
      --accent: #7aa2ff;
      --danger: #ff5b6e;
      --ok: #7dffb2;
      --border: rgba(255,255,255,.10);
      --shadow: rgba(0,0,0,.35);
      --radius: 14px;
      --px: 2px; /* fake pixel border thickness */
      --font: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }
    html,body { height: 100%; background: radial-gradient(1200px 800px at 30% 10%, #121b2b, var(--bg)); color: var(--ink); margin: 0; font-family: var(--font); }
    * { box-sizing: border-box; }
    .wrap {
      max-width: 980px;
      margin: 0 auto;
      padding: 14px 14px 18px;
      display: grid;
      gap: 12px;
    }
    header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 10px 12px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: 0 12px 30px var(--shadow);
    }
    header .title { display: flex; gap: 10px; align-items: baseline; }
    header h1 { font-size: 16px; margin: 0; letter-spacing: .5px; }
    header .sub { font-size: 12px; color: var(--muted); }
    header .pill {
      font-size: 12px; padding: 6px 10px;
      border: 1px solid var(--border); border-radius: 999px;
      background: rgba(0,0,0,.20);
      color: var(--muted);
    }

    .stage {
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: 0 12px 30px var(--shadow);
      overflow: hidden;
      position: relative;
    }

    .hud {
      display: grid;
      grid-template-columns: 1.1fr 1fr 1fr;
      gap: 8px;
      padding: 10px 10px 0;
    }
    .hud .card {
      background: rgba(0,0,0,.18);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 8px 10px;
      display: grid;
      gap: 6px;
      min-height: 56px;
    }
    .row { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .label { font-size: 11px; color: var(--muted); }
    .value { font-size: 12px; color: var(--ink); }
    .hearts { display:flex; gap: 4px; flex-wrap: wrap; }
    .heart {
      width: 14px; height: 12px; position: relative;
      transform: translateY(1px);
      filter: drop-shadow(0 2px 0 rgba(0,0,0,.35));
    }
    .heart:before, .heart:after {
      content:""; position:absolute; width: 8px; height: 8px; background: var(--danger);
      border-radius: 50%;
      top: 0;
    }
    .heart:before { left: 0; }
    .heart:after { right: 0; }
    .heart i {
      position:absolute; left: 3px; top: 3px; width: 8px; height: 8px;
      background: var(--danger);
      transform: rotate(45deg);
    }
    .heart.empty:before, .heart.empty:after, .heart.empty i { background: rgba(255,255,255,.18); }

    canvas {
      display:block;
      width: 100%;
      height: auto;
      image-rendering: pixelated;
      background: linear-gradient(180deg, #0d1420, #0a0f16);
      border-top: 1px solid var(--border);
      margin-top: 10px;
    }

    .controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      padding: 10px;
      border-top: 1px solid var(--border);
      background: rgba(0,0,0,.18);
    }
    .pad, .buttons {
      display:flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
    }
    .dpad {
      width: 150px;
      height: 92px;
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: 1fr 1fr 1fr;
      gap: 6px;
    }
    .btn {
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      width: 48px; height: 48px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.06);
      box-shadow: 0 10px 18px rgba(0,0,0,.22);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      color: var(--ink);
      touch-action: none;
    }
    .btn:active, .btn.down { transform: translateY(1px); background: rgba(255,255,255,.10); }
    .btn.small { width: 44px; height: 44px; border-radius: 12px; }
    .btn.wide { width: 76px; }

    .dpad .blank { visibility:hidden; }
    .ab { display:flex; gap: 10px; align-items:center; justify-content:center; }
    .btnA { width: 56px; height: 56px; border-radius: 999px; }
    .btnB { width: 56px; height: 56px; border-radius: 999px; }
    .btnA { background: rgba(125,255,178,.12); border-color: rgba(125,255,178,.25); }
    .btnB { background: rgba(122,162,255,.12); border-color: rgba(122,162,255,.25); }
    .meta {
      display:flex; gap: 10px; justify-content: center; align-items:center;
      margin-top: 6px;
    }
    .meta .btn { height: 42px; width: 88px; border-radius: 12px; font-size: 12px; }

    .overlay {
      position:absolute; inset: 0;
      background: rgba(0,0,0,.55);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 14px;
    }
    .overlay.show { display:flex; }
    .panel {
      width: min(520px, 100%);
      background: linear-gradient(180deg, rgba(18,25,37,.96), rgba(10,14,20,.94));
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: 0 22px 60px rgba(0,0,0,.55);
      padding: 14px;
      display: grid;
      gap: 12px;
    }
    .panel h2 { margin: 0; font-size: 14px; letter-spacing:.5px; }
    .panel p { margin: 0; color: var(--muted); font-size: 12px; line-height: 1.35; }
    .panel .choices { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .choice {
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 10px;
      background: rgba(255,255,255,.04);
      display:grid;
      gap: 6px;
    }
    .choice strong { font-size: 13px; }
    .choice span { font-size: 11px; color: var(--muted); }
    .panel .actions { display:flex; gap: 10px; justify-content:flex-end; }
    .panel .actions .btn { width: auto; padding: 0 12px; height: 42px; }
    .kbd { color: var(--muted); font-size: 11px; margin-top: 4px; }
    .scores { display:grid; gap: 10px; }
    .scoreRow { display:grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .scoreCard {
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 10px;
      background: rgba(255,255,255,.04);
      display:grid; gap: 6px;
    }
    .tag { display:inline-flex; align-items:center; gap: 6px; font-size: 11px; color: var(--muted); }
    .dot { width: 10px; height: 10px; border-radius: 999px; display:inline-block; }
    .dot.blue { background: #5aa7ff; }
    .dot.green { background: #52ff9a; }

    @media (min-width: 860px) {
      .controls { grid-template-columns: 1fr 1fr; }
      .dpad { width: 170px; height: 110px; }
      .btnA, .btnB { width: 64px; height: 64px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>Ninja Nephews</h1>
        <div class="sub">Game Boy-style • mobile-first • single + two player turns</div>
      </div>
      <div class="pill" id="topPill">Ready</div>
    </header>

    <div class="stage" id="stage">
      <div class="hud">
        <div class="card">
          <div class="row">
            <div class="label">PLAYER</div>
            <div class="value" id="hudPlayer">—</div>
          </div>
          <div class="row">
            <div class="label">HEALTH</div>
            <div class="hearts" id="hudHearts"></div>
          </div>
        </div>

        <div class="card">
          <div class="row"><div class="label">SCORE</div><div class="value" id="hudScore">0</div></div>
          <div class="row"><div class="label">LEVEL</div><div class="value" id="hudLevel">1</div></div>
        </div>

        <div class="card">
          <div class="row"><div class="label">MODE</div><div class="value" id="hudMode">—</div></div>
          <div class="row"><div class="label">TURN TIMER</div><div class="value" id="hudTimer">—</div></div>
        </div>
      </div>

      <canvas id="game" width="640" height="360" aria-label="Ninja Nephews canvas"></canvas>

      <div class="controls" aria-label="Mobile controls">
        <div class="pad">
          <div class="dpad">
            <div class="btn small blank"></div>
            <div class="btn small" id="btnUp">▲</div>
            <div class="btn small blank"></div>

            <div class="btn small" id="btnLeft">◀</div>
            <div class="btn small" id="btnDown">▼</div>
            <div class="btn small" id="btnRight">▶</div>

            <div class="btn small blank"></div>
            <div class="btn small blank"></div>
            <div class="btn small blank"></div>
          </div>
        </div>

        <div class="buttons">
          <div class="ab">
            <div class="btn btnB" id="btnB">B</div>
            <div class="btn btnA" id="btnA">A</div>
          </div>
          <div class="meta">
            <div class="btn wide" id="btnStart">START</div>
            <div class="btn wide" id="btnScores">SCORES</div>
          </div>
        </div>
      </div>

      <div class="overlay show" id="overlay">
        <div class="panel" id="panelMain">
          <h2 id="panelTitle">Ninja Nephews</h2>
          <p id="panelDesc">Choose a mode. Single player lets you pick Veeraj or Keshav. Two player alternates 90-second turns.</p>
          <div class="choices">
            <div class="choice">
              <strong>Single Player</strong>
              <span>Pick a ninja profile</span>
              <button class="btn" id="pickSingle">Play</button>
            </div>
            <div class="choice">
              <strong>Two Player</strong>
              <span>Timed turns, auto-swap</span>
              <button class="btn" id="pickDual">Play</button>
            </div>
          </div>
          <div class="kbd">Tip: Desktop controls — Arrow keys to move, A=Jump, S=Attack, Enter=Start/Pause.</div>
        </div>

        <div class="panel" id="panelPick" style="display:none;">
          <h2>Pick your ninja</h2>
          <p>Single player: choose who’s playing so their stats are saved.</p>
          <div class="choices">
            <div class="choice">
              <div class="tag"><span class="dot blue"></span> Veeraj (Blue)</div>
              <button class="btn" id="pickVeeraj">Play as Veeraj</button>
            </div>
            <div class="choice">
              <div class="tag"><span class="dot green"></span> Keshav (Green)</div>
              <button class="btn" id="pickKeshav">Play as Keshav</button>
            </div>
          </div>
          <div class="actions">
            <button class="btn" id="backToMain">Back</button>
          </div>
        </div>

        <div class="panel" id="panelScores" style="display:none;">
          <h2>Scores</h2>
          <p>Saved on this device.</p>
          <div class="scores" id="scoresBody"></div>
          <div class="actions">
            <button class="btn" id="closeScores">Close</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const STORE_KEY = "ninjaNephews.v1";
  const defaultStats = () => ({
    veeraj: { highScore: 0, bestLevel: 1, totalEnemies: 0, lastRun: 0 },
    keshav: { highScore: 0, bestLevel: 1, totalEnemies: 0, lastRun: 0 }
  });
  function loadStats() {
    try {
      const raw = localStorage.getItem(STORE_KEY);
      if (!raw) return defaultStats();
      const parsed = JSON.parse(raw);
      const base = defaultStats();
      for (const k of Object.keys(base)) parsed[k] = Object.assign(base[k], parsed[k] || {});
      return parsed;
    } catch { return defaultStats(); }
  }
  function saveStats(stats) { localStorage.setItem(STORE_KEY, JSON.stringify(stats)); }

  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const hudPlayer = document.getElementById("hudPlayer");
  const hudHearts = document.getElementById("hudHearts");
  const hudScore = document.getElementById("hudScore");
  const hudLevel = document.getElementById("hudLevel");
  const hudMode  = document.getElementById("hudMode");
  const hudTimer = document.getElementById("hudTimer");
  const topPill  = document.getElementById("topPill");

  const overlay = document.getElementById("overlay");
  const panelMain = document.getElementById("panelMain");
  const panelPick = document.getElementById("panelPick");
  const panelScores = document.getElementById("panelScores");
  const scoresBody = document.getElementById("scoresBody");

  const pickSingle = document.getElementById("pickSingle");
  const pickDual   = document.getElementById("pickDual");
  const backToMain = document.getElementById("backToMain");
  const pickVeeraj = document.getElementById("pickVeeraj");
  const pickKeshav = document.getElementById("pickKeshav");
  const btnStart   = document.getElementById("btnStart");
  const btnScores  = document.getElementById("btnScores");
  const closeScores= document.getElementById("closeScores");

  const btnLeft  = document.getElementById("btnLeft");
  const btnRight = document.getElementById("btnRight");
  const btnUp    = document.getElementById("btnUp");
  const btnDown  = document.getElementById("btnDown");
  const btnA     = document.getElementById("btnA");
  const btnB     = document.getElementById("btnB");

  const W = canvas.width, H = canvas.height;
  const GROUND_Y = 300;

  const TURN_SECONDS = 90;
  const MAX_HEARTS = 5;
  const GRAVITY = 1500;
  const MOVE_SPEED = 220;
  const JUMP_VEL = -560;

  const levels = [
    { name: "Training Dojo", length: 1500, enemyCount: 6,  healRate: 0.08, sky: "#0d1420" },
    { name: "Bamboo Forest", length: 1700, enemyCount: 8,  healRate: 0.07, sky: "#0b1520" },
    { name: "Rooftop City", length: 1900, enemyCount: 10, healRate: 0.06, sky: "#0a1220" },
    { name: "Mountain Pass", length: 2100, enemyCount: 12, healRate: 0.06, sky: "#0a0f18" },
    { name: "Boss Lair", length: 1600, enemyCount: 6, healRate: 0.05, sky: "#100a12", boss: true },
  ];

  let stats = loadStats();

  const State = { MENU:"MENU", RUNNING:"RUNNING", PAUSED:"PAUSED", TURN_END:"TURN_END" };
  let gameState = State.MENU;

  let mode = null;
  let activePlayerKey = null;
  let dualOrder = ["veeraj","keshav"];
  let dualIndex = 0;

  let levelIndex = 0;
  let camX = 0;

  let turnLeft = TURN_SECONDS;
  let turnAcc = 0;

  let score = 0;
  let enemiesDefeatedThisRun = 0;

  const input = { left:false, right:false, up:false, down:false, jump:false, attack:false };

  const player = {
    x: 80, y: GROUND_Y - 28, w: 18, h: 28,
    vx: 0, vy: 0,
    onGround: true,
    hearts: MAX_HEARTS,
    invuln: 0,
    facing: 1,
    attackCD: 0
  };

  let enemies = [];
  let heals = [];
  let boss = null;

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const colorForPlayer = (k)=> k==="veeraj" ? "#5aa7ff" : "#52ff9a";
  const nameForPlayer  = (k)=> k==="veeraj" ? "Veeraj" : "Keshav";

  function setTopPill(t){ topPill.textContent=t; }
  function showOverlay(which){
    overlay.classList.add("show");
    panelMain.style.display = which==="main" ? "grid" : "none";
    panelPick.style.display = which==="pick" ? "grid" : "none";
    panelScores.style.display = which==="scores" ? "grid" : "none";
  }
  function hideOverlay(){ overlay.classList.remove("show"); }

  function renderHearts(){
    hudHearts.innerHTML="";
    for(let i=0;i<MAX_HEARTS;i++){
      const d=document.createElement("div");
      d.className="heart"+(i<player.hearts?"":" empty");
      d.appendChild(document.createElement("i"));
      hudHearts.appendChild(d);
    }
  }
  function refreshHUD(){
    hudPlayer.textContent = activePlayerKey ? nameForPlayer(activePlayerKey) : "—";
    hudScore.textContent = String(score);
    hudLevel.textContent = String(levelIndex+1);
    hudMode.textContent = mode ? (mode==="single" ? "Single" : "Two Player") : "—";
    hudTimer.textContent = (mode==="dual") ? `${Math.ceil(turnLeft)}s` : "—";
    renderHearts();
  }

  function loadLevel(i){
    const lvl=levels[i];
    enemies=[]; heals=[]; boss=null;
    const startX=250, endX=lvl.length-180;
    for(let n=0;n<lvl.enemyCount;n++){
      const x=startX+(endX-startX)*(n/(lvl.enemyCount));
      enemies.push({ x, y: GROUND_Y-22, w:18, h:22, vx:(Math.random()<0.5?-1:1)*(70+Math.random()*40), hp:2, hitCD:0 });
    }
    if(lvl.boss){
      boss={ x:lvl.length-240, y:GROUND_Y-56, w:46, h:56, hp:18, atkCD:1.2, dir:-1 };
    }
  }

  function resetRun(){
    levelIndex=0; camX=0; score=0; enemiesDefeatedThisRun=0;
    player.x=80; player.y=GROUND_Y-player.h; player.vx=0; player.vy=0;
    player.hearts=MAX_HEARTS; player.invuln=0; player.attackCD=0;
    turnLeft=TURN_SECONDS; turnAcc=0;
    loadLevel(levelIndex);
    refreshHUD();
  }

  function saveRunResults(){
    if(!activePlayerKey) return;
    const s=stats[activePlayerKey];
    s.lastRun=score;
    if(score>s.highScore) s.highScore=score;
    if((levelIndex+1)>s.bestLevel) s.bestLevel=(levelIndex+1);
    s.totalEnemies += enemiesDefeatedThisRun;
    saveStats(stats);
  }

  function endTurn(reason){
    saveRunResults();
    gameState=State.TURN_END;
    setTopPill(reason==="timer"?"Turn over!":reason==="death"?"Knocked out!":"Victory!");
    setTimeout(()=>{
      if(mode==="dual"){
        dualIndex=(dualIndex+1)%dualOrder.length;
        activePlayerKey=dualOrder[dualIndex];
        resetRun();
        gameState=State.RUNNING;
        setTopPill(`${nameForPlayer(activePlayerKey)}'s turn`);
      } else {
        gameState=State.MENU;
        showOverlay("main");
        setTopPill("Ready");
      }
    },900);
  }

  function bindHold(btn,onDown,onUp){
    const down=(e)=>{ e.preventDefault(); btn.classList.add("down"); onDown(); };
    const up=(e)=>{ e.preventDefault(); btn.classList.remove("down"); onUp(); };
    btn.addEventListener("pointerdown",down);
    btn.addEventListener("pointerup",up);
    btn.addEventListener("pointercancel",up);
    btn.addEventListener("pointerleave",up);
  }
  bindHold(btnLeft, ()=>input.left=true, ()=>input.left=false);
  bindHold(btnRight,()=>input.right=true,()=>input.right=false);
  bindHold(btnUp,   ()=>input.up=true,   ()=>input.up=false);
  bindHold(btnDown, ()=>input.down=true, ()=>input.down=false);

  btnA.addEventListener("pointerdown",(e)=>{ e.preventDefault(); btnA.classList.add("down"); input.jump=true; });
  btnA.addEventListener("pointerup",(e)=>{ e.preventDefault(); btnA.classList.remove("down"); input.jump=false; });
  btnA.addEventListener("pointercancel",(e)=>{ e.preventDefault(); btnA.classList.remove("down"); input.jump=false; });

  btnB.addEventListener("pointerdown",(e)=>{ e.preventDefault(); btnB.classList.add("down"); input.attack=true; });
  btnB.addEventListener("pointerup",(e)=>{ e.preventDefault(); btnB.classList.remove("down"); input.attack=false; });
  btnB.addEventListener("pointercancel",(e)=>{ e.preventDefault(); btnB.classList.remove("down"); input.attack=false; });

  btnStart.addEventListener("click",()=>togglePauseOrStart());
  btnScores.addEventListener("click",()=>showScores());

  window.addEventListener("keydown",(e)=>{
    const k=e.key.toLowerCase();
    if(k==="arrowleft") input.left=true;
    if(k==="arrowright") input.right=true;
    if(k==="arrowup") input.up=true;
    if(k==="arrowdown") input.down=true;
    if(k==="a") input.jump=true;
    if(k==="s") input.attack=true;
    if(k==="enter") togglePauseOrStart();
  });
  window.addEventListener("keyup",(e)=>{
    const k=e.key.toLowerCase();
    if(k==="arrowleft") input.left=false;
    if(k==="arrowright") input.right=false;
    if(k==="arrowup") input.up=false;
    if(k==="arrowdown") input.down=false;
    if(k==="a") input.jump=false;
    if(k==="s") input.attack=false;
  });

  pickSingle.addEventListener("click",()=>showOverlay("pick"));
  pickDual.addEventListener("click",()=>{
    mode="dual"; dualIndex=0; activePlayerKey=dualOrder[dualIndex];
    hideOverlay(); startGame(); setTopPill(`${nameForPlayer(activePlayerKey)}'s turn`);
  });
  backToMain.addEventListener("click",()=>showOverlay("main"));
  pickVeeraj.addEventListener("click",()=>{
    mode="single"; activePlayerKey="veeraj";
    hideOverlay(); startGame(); setTopPill("Go, Veeraj!");
  });
  pickKeshav.addEventListener("click",()=>{
    mode="single"; activePlayerKey="keshav";
    hideOverlay(); startGame(); setTopPill("Go, Keshav!");
  });

  closeScores.addEventListener("click",()=>{
    if(gameState===State.RUNNING || gameState===State.PAUSED) hideOverlay();
    else showOverlay("main");
  });

  function togglePauseOrStart(){
    if(gameState===State.MENU) return;
    if(gameState===State.RUNNING){
      gameState=State.PAUSED;
      showOverlay("scores");
      renderScores();
      setTopPill("Paused");
    } else if(gameState===State.PAUSED){
      hideOverlay();
      gameState=State.RUNNING;
      setTopPill(mode==="dual"?`${nameForPlayer(activePlayerKey)}'s turn`:"Play!");
    }
  }
  function startGame(){ resetRun(); gameState=State.RUNNING; refreshHUD(); }

  function showScores(){ stats=loadStats(); renderScores(); showOverlay("scores"); }
  function renderScores(){
    const makeCard=(key)=>{
      const s=stats[key];
      const dotClass=key==="veeraj"?"blue":"green";
      const name=nameForPlayer(key);
      return `
        <div class="scoreCard">
          <div class="tag"><span class="dot ${dotClass}"></span> ${name}</div>
          <div class="row"><div class="label">High Score</div><div class="value">${s.highScore}</div></div>
          <div class="row"><div class="label">Best Level</div><div class="value">${s.bestLevel}</div></div>
          <div class="row"><div class="label">Total Enemies</div><div class="value">${s.totalEnemies}</div></div>
          <div class="row"><div class="label">Last Run</div><div class="value">${s.lastRun}</div></div>
        </div>`;
    };
    scoresBody.innerHTML = `
      <div class="scoreRow">
        ${makeCard("veeraj")}
        ${makeCard("keshav")}
      </div>
      <div class="kbd">Saved locally on this device (no accounts).</div>`;
  }

  function rectsOverlap(a,b){
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  function spawnHealIfLucky(levelDef){
    if(Math.random()<levelDef.healRate){
      const x=clamp(player.x+220+Math.random()*320,120,levelDef.length-160);
      heals.push({ x, y:GROUND_Y-18, w:12, h:12, amt: Math.random()<0.7?1:2 });
    }
  }

  function damagePlayer(dmg){
    if(player.invuln>0) return;
    player.hearts=clamp(player.hearts-dmg,0,MAX_HEARTS);
    player.invuln=0.9;
    if(player.hearts<=0){ refreshHUD(); endTurn("death"); }
  }

  function playerAttackHitbox(){
    const reach=20;
    return (player.facing===1)
      ? { x: player.x+player.w, y: player.y+6, w: reach, h: player.h-12 }
      : { x: player.x-reach, y: player.y+6, w: reach, h: player.h-12 };
  }

  function nextLevelOrWin(){
    const lvl=levels[levelIndex];
    const atEnd = (player.x >= lvl.length - 110);
    if(!atEnd) return;
    if(lvl.boss){
      if(boss && boss.hp>0) return;
      score += 1000;
      refreshHUD();
      endTurn("win");
      return;
    }
    score += 300;
    levelIndex++;
    if(levelIndex>=levels.length){ endTurn("win"); return; }
    loadLevel(levelIndex);
    player.x=80; player.y=GROUND_Y-player.h; camX=0;
    refreshHUD();
    setTopPill(`Level ${levelIndex+1}: ${levels[levelIndex].name}`);
  }

  function clearBG(levelDef){
    ctx.fillStyle=levelDef.sky;
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle="rgba(0,0,0,.12)";
    for(let y=0;y<H;y+=4) ctx.fillRect(0,y,W,1);
  }
  function drawGround(){
    ctx.fillStyle="rgba(255,255,255,.08)";
    ctx.fillRect(0,GROUND_Y,W,H-GROUND_Y);
    ctx.fillStyle="rgba(255,255,255,.12)";
    ctx.fillRect(0,GROUND_Y,W,2);
  }
  function drawPlayer(){
    const c=colorForPlayer(activePlayerKey);
    const px=Math.floor(player.x-camX), py=Math.floor(player.y);
    ctx.fillStyle = (player.invuln>0) ? "rgba(255,255,255,.65)" : c;
    ctx.fillRect(px,py,player.w,player.h);
    ctx.fillStyle="rgba(0,0,0,.35)";
    ctx.fillRect(px,py+6,player.w,3);
    ctx.fillStyle="rgba(0,0,0,.55)";
    const ex = player.facing===1 ? px+player.w-6 : px+3;
    ctx.fillRect(ex,py+12,3,3);
  }
  function drawEnemy(e){
    const px=Math.floor(e.x-camX), py=Math.floor(e.y);
    ctx.fillStyle="rgba(255,255,255,.20)";
    ctx.fillRect(px,py,e.w,e.h);
    ctx.fillStyle="rgba(0,0,0,.45)";
    ctx.fillRect(px+4,py+7,3,3);
  }
  function drawHeal(h){
    const px=Math.floor(h.x-camX), py=Math.floor(h.y);
    ctx.fillStyle = h.amt===1 ? "rgba(255,91,110,.75)" : "rgba(255,91,110,.95)";
    ctx.fillRect(px,py,h.w,h.h);
    ctx.fillStyle="rgba(255,255,255,.40)";
    ctx.fillRect(px+4,py+2,4,2);
  }
  function drawBoss(b){
    const px=Math.floor(b.x-camX), py=Math.floor(b.y);
    ctx.fillStyle="rgba(255,255,255,.28)";
    ctx.fillRect(px,py,b.w,b.h);
    ctx.fillStyle="rgba(0,0,0,.55)";
    ctx.fillRect(px+10,py+18,6,6);
    ctx.fillRect(px+b.w-16,py+18,6,6);
    const barW=180, barH=8, bx=12, by=14;
    ctx.fillStyle="rgba(255,255,255,.14)";
    ctx.fillRect(bx,by,barW,barH);
    const pct=clamp(b.hp/18,0,1);
    ctx.fillStyle="rgba(255,91,110,.85)";
    ctx.fillRect(bx,by,Math.floor(barW*pct),barH);
    ctx.fillStyle="rgba(255,255,255,.60)";
    ctx.fillText("BOSS",bx,by-2);
  }
  function drawEndFlag(levelDef){
    const fx=levelDef.length-90-camX, baseY=GROUND_Y;
    ctx.fillStyle="rgba(255,255,255,.14)";
    ctx.fillRect(Math.floor(fx),baseY-60,4,60);
    ctx.fillStyle="rgba(125,255,178,.35)";
    ctx.fillRect(Math.floor(fx)+4,baseY-56,26,14);
  }

  let last=performance.now();
  function tick(now){
    const dt=Math.min(0.033,(now-last)/1000); last=now;
    if(gameState===State.RUNNING) update(dt);
    render();
    requestAnimationFrame(tick);
  }

  function update(dt){
    const lvl=levels[levelIndex];

    if(mode==="dual"){
      turnLeft -= dt;
      if(turnLeft<=0){
        turnLeft=0; refreshHUD(); endTurn("timer"); return;
      }
    }

    player.vx=0;
    if(input.left){ player.vx=-MOVE_SPEED; player.facing=-1; }
    if(input.right){ player.vx= MOVE_SPEED; player.facing= 1; }

    if(input.jump && player.onGround){
      player.vy=JUMP_VEL; player.onGround=false;
    }

    player.vy += GRAVITY*dt;
    player.x += player.vx*dt;
    player.y += player.vy*dt;

    player.x = clamp(player.x, 20, lvl.length-40);

    if(player.y+player.h>=GROUND_Y){
      player.y=GROUND_Y-player.h; player.vy=0; player.onGround=true;
    }

    camX = clamp(player.x-160, 0, lvl.length-W);

    turnAcc += dt;
    if(turnAcc>=0.35){ turnAcc=0; spawnHealIfLucky(lvl); }

    if(player.invuln>0) player.invuln -= dt;
    if(player.attackCD>0) player.attackCD -= dt;

    if(input.attack && player.attackCD<=0){
      player.attackCD=0.28;
      const hb=playerAttackHitbox();
      for(const e of enemies){
        if(e.hp<=0) continue;
        if(rectsOverlap(hb,e)){
          e.hp-=1; e.hitCD=0.15;
          if(e.hp<=0){ score+=120; enemiesDefeatedThisRun+=1; }
          else score+=30;
        }
      }
      if(boss && boss.hp>0 && rectsOverlap(hb,boss)){
        boss.hp-=1; score+=50;
        if(boss.hp<=0) score+=600;
      }
    }

    for(const e of enemies){
      if(e.hp<=0) continue;
      e.x += e.vx*dt;
      if(e.x<60) e.vx=Math.abs(e.vx);
      if(e.x>lvl.length-80) e.vx=-Math.abs(e.vx);
      if(e.hitCD>0) e.hitCD -= dt;
      if(rectsOverlap(player,e)){
        damagePlayer(1);
        player.vy=-220;
      }
    }

    heals = heals.filter(h => (h.x-camX) > -80 && (h.x-camX) < W+80);
    for(let i=heals.length-1;i>=0;i--){
      const h=heals[i];
      if(rectsOverlap(player,h)){
        player.hearts = clamp(player.hearts + h.amt, 0, MAX_HEARTS);
        score += (h.amt===2?80:40);
        heals.splice(i,1);
      }
    }

    if(boss && boss.hp>0){
      boss.atkCD -= dt;
      if(boss.atkCD<=0){
        boss.atkCD=1.4;
        boss.dir = (player.x<boss.x?-1:1);
        boss.x += boss.dir*80;
      } else {
        boss.dir = (player.x<boss.x?-1:1);
        boss.x += boss.dir*35*dt;
      }
      boss.x = clamp(boss.x, 200, lvl.length-140);
      if(rectsOverlap(player,boss)){
        damagePlayer(1);
        player.vy=-250;
      }
    }

    nextLevelOrWin();
    refreshHUD();
  }

  function render(){
    const lvl=levels[levelIndex];
    clearBG(lvl);
    drawGround();

    ctx.fillStyle="rgba(255,255,255,.06)";
    for(let i=0;i<10;i++){
      const x=(i*240-(camX*0.2))%(W+240)-80;
      const y=60+(i%3)*22;
      ctx.fillRect(Math.floor(x),y,70,10);
    }

    ctx.fillStyle="rgba(255,255,255,.65)";
    ctx.fillText(`Level ${levelIndex+1}: ${lvl.name}`, 12, H-12);

    drawEndFlag(lvl);

    for(const h of heals) drawHeal(h);
    for(const e of enemies) if(e.hp>0) drawEnemy(e);
    if(boss && boss.hp>0) drawBoss(boss);
    drawPlayer();

    if(gameState===State.PAUSED){
      ctx.fillStyle="rgba(0,0,0,.45)";
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle="rgba(255,255,255,.75)";
      ctx.fillText("PAUSED", W/2-30, H/2);
    }
  }

  function init(){
    stats=loadStats();
    showOverlay("main");
    gameState=State.MENU;
    setTopPill("Ready");
    refreshHUD();
    requestAnimationFrame(tick);
  }
  init();
})();
</script>
</body>
</html>
